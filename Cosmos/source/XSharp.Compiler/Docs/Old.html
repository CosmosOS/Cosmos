<%@ Page Language="C#" AutoEventWireup="true" CodeFile="index.html.cs" Inherits="XSharp_index" %>

<!DOCTYPE HTML PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
<head>
    <title></title>
</head>
<body>
    <h3>
        X#<p>
            X# compiles C# code into assembly, but does it as it runs. This allows the use
            of intellisense, and modification of the output using C#.
        </p>
        <li>
            One of the goals of Cosmos is the need to write very little assembly, so only
            debug stub, compiler users, etc need assembly. Too much work on X# may not be
            worth the resources required.
        </li>
        <h3>
            Consts
        </h3>
        <p>
            ref with #. else user would need to use @, and if not woudl get [value] instead.
            ie consts have direct ref as default while fields have indirect as default. Also
            treat consts diff since they can only be read from and not assigned, and at
            parse time we dont know if a label is const, var or other.
        </p>
        <p>
            all consts are group based. Need provision for globals in future. Consts cannot
            be local.
        </p>
        <h3>
            Method
        </h3>
        <p>
            name()
        </p>
        <li>
            <h3>
                Usage
            </h3>
            <p>
                look in tokenpatterns.cs for more
            </p>
            <h3>
                Labels
            </h3>
            <p>
                ..Global
            </p>
            <p>
                .Group
            </p>
            <p>
                Local
            </p>
            <p>
                Think of it like a directory path, .. and . are up.
            </p>
            <h3>
                Checkpoint &#39;text&#39;
            </h3>
            <p>
                &nbsp;
            </p>
            <h3>
                if reg = x goto label
            </h3>
            <p>
                =<br />
                !=<br />
                &gt;<br />
                &gt;=<br />
                &lt;<br />
                &lt;=
            </p>
            <h3>
                Register Arithmetic
            </h3>
            <p>
                EBP = EBP + 32;<br />
                This is not possible because C# operator overloading does not look at return
                type but only the operand types. That is C# sees Register + int. If we supported
                the previous example, then X# could not support:<br />
                EAX = Memory[EBP + 4];<br />
                In short, C# sees these two as the same and so X# can only support one. Because
                the memory addressing is used more frequently than adding a constant to a
                register, X# supports it.<br />
                To add a constant to a register use:<br />
                EBP.Add(32);
            </p>
            <h3>
                Register-- / Register++
            </h3>
            <p>
                Valid and usable. Correspond to Inc and Dec.
            </p>
            <h3>
                Register Shifting
            </h3>
            <p>
                Example:<br />
                EAX &lt;&lt; 2
            </p>
            <h3>
                Rotate
            </h3>
            <p>
                &nbsp;~ &quot;infinite&quot; shift because it loops
            </p>
            <h3>
                Register Methods
            </h3>
            <ul>
                <li>Add</li>
                <li>Sub</li>
                <li>Compare</li>
                <li>Test</li>
            </ul>
            <h3>
                Register = int
            </h3>
            <p>
                Example:<br />
                EAX = $40<br />
                EAX = 64
            </p>
            <h3>
                Register = Register
            </h3>
            <p>
                Example:<br />
                EAX = EBP
            </p>
            <h3>
                Register = Memory[Address];<br />
                Register = Memory[Address + int];
            </h3>
            <p>
                Address can be a string label. i.e. EAX = Memory[&quot;Data1&quot;]
            </p>
            <h3>
                Register = Port[x]<br />
                Register = Port[EAX]
            </h3>
            <p>
                public static implicit operator RegisterEAX(Cosmos.Assembler.ElementReference aReference) {
                Instance.Move(aReference); return Instance; }
            </p>
            <h3>
                Register = Label
            </h3>
            <p>
                Example:<br />
                EAX = AddressOf(&quot;Labelname&quot;);
            </p>
        </li>
    </h3>
</body>
</html>
