This is bfd.info, produced by makeinfo version 4.3 from bfd.texinfo.

START-INFO-DIR-ENTRY
* Bfd: (bfd).                   The Binary File Descriptor library.
END-INFO-DIR-ENTRY

   This file documents the BFD library.

   Copyright (C) 1991, 2000, 2001, 2003 Free Software Foundation, Inc.

   Permission is granted to copy, distribute and/or modify this document
     under the terms of the GNU Free Documentation License, Version 1.1
     or any later version published by the Free Software Foundation;
   with no Invariant Sections, with no Front-Cover Texts, and with no
    Back-Cover Texts.  A copy of the license is included in the
section entitled "GNU Free Documentation License".


File: bfd.info,  Node: typedef asection,  Next: section prototypes,  Prev: Section Output,  Up: Sections

typedef asection
----------------

   Here is the section structure:


     /* This structure is used for a comdat section, as in PE.  A comdat
        section is associated with a particular symbol.  When the linker
        sees a comdat section, it keeps only one of the sections with a
        given name and associated with a given symbol.  */
     
     struct bfd_comdat_info
     {
       /* The name of the symbol associated with a comdat section.  */
       const char *name;
     
       /* The local symbol table index of the symbol associated with a
          comdat section.  This is only meaningful to the object file format
          specific code; it is not an index into the list returned by
          bfd_canonicalize_symtab.  */
       long symbol;
     };
     
     typedef struct sec
     {
       /* The name of the section; the name isn't a copy, the pointer is
          the same as that passed to bfd_make_section.  */
       const char *name;
     
       /* A unique sequence number.  */
       int id;
     
       /* Which section in the bfd; 0..n-1 as sections are created in a bfd.  */
       int index;
     
       /* The next section in the list belonging to the BFD, or NULL.  */
       struct sec *next;
     
       /* The field flags contains attributes of the section. Some
          flags are read in from the object file, and some are
          synthesized from other information.  */
       flagword flags;
     
     #define SEC_NO_FLAGS   0x000
     
       /* Tells the OS to allocate space for this section when loading.
          This is clear for a section containing debug information only.  */
     #define SEC_ALLOC      0x001
     
       /* Tells the OS to load the section from the file when loading.
          This is clear for a .bss section.  */
     #define SEC_LOAD       0x002
     
       /* The section contains data still to be relocated, so there is
          some relocation information too.  */
     #define SEC_RELOC      0x004
     
       /* ELF reserves 4 processor specific bits and 8 operating system
          specific bits in sh_flags; at present we can get away with just
          one in communicating between the assembler and BFD, but this
          isn't a good long-term solution.  */
     #define SEC_ARCH_BIT_0 0x008
     
       /* A signal to the OS that the section contains read only data.  */
     #define SEC_READONLY   0x010
     
       /* The section contains code only.  */
     #define SEC_CODE       0x020
     
       /* The section contains data only.  */
     #define SEC_DATA       0x040
     
       /* The section will reside in ROM.  */
     #define SEC_ROM        0x080
     
       /* The section contains constructor information. This section
          type is used by the linker to create lists of constructors and
          destructors used by `g++'. When a back end sees a symbol
          which should be used in a constructor list, it creates a new
          section for the type of name (e.g., `__CTOR_LIST__'), attaches
          the symbol to it, and builds a relocation. To build the lists
          of constructors, all the linker has to do is catenate all the
          sections called `__CTOR_LIST__' and relocate the data
          contained within - exactly the operations it would peform on
          standard data.  */
     #define SEC_CONSTRUCTOR 0x100
     
       /* The section has contents - a data section could be
          `SEC_ALLOC' | `SEC_HAS_CONTENTS'; a debug section could be
          `SEC_HAS_CONTENTS'  */
     #define SEC_HAS_CONTENTS 0x200
     
       /* An instruction to the linker to not output the section
          even if it has information which would normally be written.  */
     #define SEC_NEVER_LOAD 0x400
     
       /* The section is a COFF shared library section.  This flag is
          only for the linker.  If this type of section appears in
          the input file, the linker must copy it to the output file
          without changing the vma or size.  FIXME: Although this
          was originally intended to be general, it really is COFF
          specific (and the flag was renamed to indicate this).  It
          might be cleaner to have some more general mechanism to
          allow the back end to control what the linker does with
          sections.  */
     #define SEC_COFF_SHARED_LIBRARY 0x800
     
       /* The section contains thread local data.  */
     #define SEC_THREAD_LOCAL 0x1000
     
       /* The section has GOT references.  This flag is only for the
          linker, and is currently only used by the elf32-hppa back end.
          It will be set if global offset table references were detected
          in this section, which indicate to the linker that the section
          contains PIC code, and must be handled specially when doing a
          static link.  */
     #define SEC_HAS_GOT_REF 0x4000
     
       /* The section contains common symbols (symbols may be defined
          multiple times, the value of a symbol is the amount of
          space it requires, and the largest symbol value is the one
          used).  Most targets have exactly one of these (which we
          translate to bfd_com_section_ptr), but ECOFF has two.  */
     #define SEC_IS_COMMON 0x8000
     
       /* The section contains only debugging information.  For
          example, this is set for ELF .debug and .stab sections.
          strip tests this flag to see if a section can be
          discarded.  */
     #define SEC_DEBUGGING 0x10000
     
       /* The contents of this section are held in memory pointed to
          by the contents field.  This is checked by bfd_get_section_contents,
          and the data is retrieved from memory if appropriate.  */
     #define SEC_IN_MEMORY 0x20000
     
       /* The contents of this section are to be excluded by the
          linker for executable and shared objects unless those
          objects are to be further relocated.  */
     #define SEC_EXCLUDE 0x40000
     
       /* The contents of this section are to be sorted based on the sum of
          the symbol and addend values specified by the associated relocation
          entries.  Entries without associated relocation entries will be
          appended to the end of the section in an unspecified order.  */
     #define SEC_SORT_ENTRIES 0x80000
     
       /* When linking, duplicate sections of the same name should be
          discarded, rather than being combined into a single section as
          is usually done.  This is similar to how common symbols are
          handled.  See SEC_LINK_DUPLICATES below.  */
     #define SEC_LINK_ONCE 0x100000
     
       /* If SEC_LINK_ONCE is set, this bitfield describes how the linker
          should handle duplicate sections.  */
     #define SEC_LINK_DUPLICATES 0x600000
     
       /* This value for SEC_LINK_DUPLICATES means that duplicate
          sections with the same name should simply be discarded.  */
     #define SEC_LINK_DUPLICATES_DISCARD 0x0
     
       /* This value for SEC_LINK_DUPLICATES means that the linker
          should warn if there are any duplicate sections, although
          it should still only link one copy.  */
     #define SEC_LINK_DUPLICATES_ONE_ONLY 0x200000
     
       /* This value for SEC_LINK_DUPLICATES means that the linker
          should warn if any duplicate sections are a different size.  */
     #define SEC_LINK_DUPLICATES_SAME_SIZE 0x400000
     
       /* This value for SEC_LINK_DUPLICATES means that the linker
          should warn if any duplicate sections contain different
          contents.  */
     #define SEC_LINK_DUPLICATES_SAME_CONTENTS 0x600000
     
       /* This section was created by the linker as part of dynamic
          relocation or other arcane processing.  It is skipped when
          going through the first-pass output, trusting that someone
          else up the line will take care of it later.  */
     #define SEC_LINKER_CREATED 0x800000
     
       /* This section should not be subject to garbage collection.  */
     #define SEC_KEEP 0x1000000
     
       /* This section contains "short" data, and should be placed
          "near" the GP.  */
     #define SEC_SMALL_DATA 0x2000000
     
       /* This section contains data which may be shared with other
          executables or shared objects.  */
     #define SEC_SHARED 0x4000000
     
       /* When a section with this flag is being linked, then if the size of
          the input section is less than a page, it should not cross a page
          boundary.  If the size of the input section is one page or more, it
          should be aligned on a page boundary.  */
     #define SEC_BLOCK 0x8000000
     
       /* Conditionally link this section; do not link if there are no
          references found to any symbol in the section.  */
     #define SEC_CLINK 0x10000000
     
       /* Attempt to merge identical entities in the section.
          Entity size is given in the entsize field.  */
     #define SEC_MERGE 0x20000000
     
       /* If given with SEC_MERGE, entities to merge are zero terminated
          strings where entsize specifies character size instead of fixed
          size entries.  */
     #define SEC_STRINGS 0x40000000
     
       /* This section contains data about section groups.  */
     #define SEC_GROUP 0x80000000
     
       /*  End of section flags.  */
     
       /* Some internal packed boolean fields.  */
     
       /* See the vma field.  */
       unsigned int user_set_vma : 1;
     
       /* Whether relocations have been processed.  */
       unsigned int reloc_done : 1;
     
       /* A mark flag used by some of the linker backends.  */
       unsigned int linker_mark : 1;
     
       /* Another mark flag used by some of the linker backends.  Set for
          output sections that have an input section.  */
       unsigned int linker_has_input : 1;
     
       /* A mark flag used by some linker backends for garbage collection.  */
       unsigned int gc_mark : 1;
     
       /* The following flags are used by the ELF linker. */
     
       /* Mark sections which have been allocated to segments.  */
       unsigned int segment_mark : 1;
     
       /* Type of sec_info information.  */
       unsigned int sec_info_type:3;
     #define ELF_INFO_TYPE_NONE      0
     #define ELF_INFO_TYPE_STABS     1
     #define ELF_INFO_TYPE_MERGE     2
     #define ELF_INFO_TYPE_EH_FRAME  3
     #define ELF_INFO_TYPE_JUST_SYMS 4
     
       /* Nonzero if this section uses RELA relocations, rather than REL.  */
       unsigned int use_rela_p:1;
     
       /* Bits used by various backends.  */
       unsigned int has_tls_reloc:1;
     
       /* Nonzero if this section needs the relax finalize pass.  */
       unsigned int need_finalize_relax:1;
     
       /* Usused bits.  */
       unsigned int flag12:1;
       unsigned int flag13:1;
       unsigned int flag14:1;
       unsigned int flag15:1;
       unsigned int flag16:4;
       unsigned int flag20:4;
       unsigned int flag24:8;
     
       /* End of internal packed boolean fields.  */
     
       /*  The virtual memory address of the section - where it will be
           at run time.  The symbols are relocated against this.  The
           user_set_vma flag is maintained by bfd; if it's not set, the
           backend can assign addresses (for example, in `a.out', where
           the default address for `.data' is dependent on the specific
           target and various flags).  */
       bfd_vma vma;
     
       /*  The load address of the section - where it would be in a
           rom image; really only used for writing section header
           information.  */
       bfd_vma lma;
     
       /* The size of the section in octets, as it will be output.
          Contains a value even if the section has no contents (e.g., the
          size of `.bss').  This will be filled in after relocation.  */
       bfd_size_type _cooked_size;
     
       /* The original size on disk of the section, in octets.  Normally this
          value is the same as the size, but if some relaxing has
          been done, then this value will be bigger.  */
       bfd_size_type _raw_size;
     
       /* If this section is going to be output, then this value is the
          offset in *bytes* into the output section of the first byte in the
          input section (byte ==> smallest addressable unit on the
          target).  In most cases, if this was going to start at the
          100th octet (8-bit quantity) in the output section, this value
          would be 100.  However, if the target byte size is 16 bits
          (bfd_octets_per_byte is "2"), this value would be 50.  */
       bfd_vma output_offset;
     
       /* The output section through which to map on output.  */
       struct sec *output_section;
     
       /* The alignment requirement of the section, as an exponent of 2 -
          e.g., 3 aligns to 2^3 (or 8).  */
       unsigned int alignment_power;
     
       /* If an input section, a pointer to a vector of relocation
          records for the data in this section.  */
       struct reloc_cache_entry *relocation;
     
       /* If an output section, a pointer to a vector of pointers to
          relocation records for the data in this section.  */
       struct reloc_cache_entry **orelocation;
     
       /* The number of relocation records in one of the above.  */
       unsigned reloc_count;
     
       /* Information below is back end specific - and not always used
          or updated.  */
     
       /* File position of section data.  */
       file_ptr filepos;
     
       /* File position of relocation info.  */
       file_ptr rel_filepos;
     
       /* File position of line data.  */
       file_ptr line_filepos;
     
       /* Pointer to data for applications.  */
       PTR userdata;
     
       /* If the SEC_IN_MEMORY flag is set, this points to the actual
          contents.  */
       unsigned char *contents;
     
       /* Attached line number information.  */
       alent *lineno;
     
       /* Number of line number records.  */
       unsigned int lineno_count;
     
       /* Entity size for merging purposes.  */
       unsigned int entsize;
     
       /* Optional information about a COMDAT entry; NULL if not COMDAT.  */
       struct bfd_comdat_info *comdat;
     
       /* When a section is being output, this value changes as more
          linenumbers are written out.  */
       file_ptr moving_line_filepos;
     
       /* What the section number is in the target world.  */
       int target_index;
     
       PTR used_by_bfd;
     
       /* If this is a constructor section then here is a list of the
          relocations created to relocate items within it.  */
       struct relent_chain *constructor_chain;
     
       /* The BFD which owns the section.  */
       bfd *owner;
     
       /* A symbol which points at this section only.  */
       struct symbol_cache_entry *symbol;
       struct symbol_cache_entry **symbol_ptr_ptr;
     
       struct bfd_link_order *link_order_head;
       struct bfd_link_order *link_order_tail;
     } asection;
     
     /* These sections are global, and are managed by BFD.  The application
        and target back end are not permitted to change the values in
        these sections.  New code should use the section_ptr macros rather
        than referring directly to the const sections.  The const sections
        may eventually vanish.  */
     #define BFD_ABS_SECTION_NAME "*ABS*"
     #define BFD_UND_SECTION_NAME "*UND*"
     #define BFD_COM_SECTION_NAME "*COM*"
     #define BFD_IND_SECTION_NAME "*IND*"
     
     /* The absolute section.  */
     extern const asection bfd_abs_section;
     #define bfd_abs_section_ptr ((asection *) &bfd_abs_section)
     #define bfd_is_abs_section(sec) ((sec) == bfd_abs_section_ptr)
     /* Pointer to the undefined section.  */
     extern const asection bfd_und_section;
     #define bfd_und_section_ptr ((asection *) &bfd_und_section)
     #define bfd_is_und_section(sec) ((sec) == bfd_und_section_ptr)
     /* Pointer to the common section.  */
     extern const asection bfd_com_section;
     #define bfd_com_section_ptr ((asection *) &bfd_com_section)
     /* Pointer to the indirect section.  */
     extern const asection bfd_ind_section;
     #define bfd_ind_section_ptr ((asection *) &bfd_ind_section)
     #define bfd_is_ind_section(sec) ((sec) == bfd_ind_section_ptr)
     
     #define bfd_is_const_section(SEC)              \
      (   ((SEC) == bfd_abs_section_ptr)            \
       || ((SEC) == bfd_und_section_ptr)            \
       || ((SEC) == bfd_com_section_ptr)            \
       || ((SEC) == bfd_ind_section_ptr))
     
     extern const struct symbol_cache_entry * const bfd_abs_symbol;
     extern const struct symbol_cache_entry * const bfd_com_symbol;
     extern const struct symbol_cache_entry * const bfd_und_symbol;
     extern const struct symbol_cache_entry * const bfd_ind_symbol;
     #define bfd_get_section_size_before_reloc(section) \
          ((section)->reloc_done ? (abort (), (bfd_size_type) 1) \
                                 : (section)->_raw_size)
     #define bfd_get_section_size_after_reloc(section) \
          ((section)->reloc_done ? (section)->_cooked_size \
                                 : (abort (), (bfd_size_type) 1))
     
     /* Macros to handle insertion and deletion of a bfd's sections.  These
        only handle the list pointers, ie. do not adjust section_count,
        target_index etc.  */
     #define bfd_section_list_remove(ABFD, PS) \
       do                                                   \
         {                                                  \
           asection **_ps = PS;                             \
           asection *_s = *_ps;                             \
           *_ps = _s->next;                                 \
           if (_s->next == NULL)                            \
             (ABFD)->section_tail = _ps;                    \
         }                                                  \
       while (0)
     #define bfd_section_list_insert(ABFD, PS, S) \
       do                                                   \
         {                                                  \
           asection **_ps = PS;                             \
           asection *_s = S;                                \
           _s->next = *_ps;                                 \
           *_ps = _s;                                       \
           if (_s->next == NULL)                            \
             (ABFD)->section_tail = &_s->next;              \
         }                                                  \
       while (0)


File: bfd.info,  Node: section prototypes,  Prev: typedef asection,  Up: Sections

Section prototypes
------------------

   These are the functions exported by the section handling part of BFD.

`bfd_section_list_clear'
........................

   *Synopsis*
     void bfd_section_list_clear (bfd *);
   *Description*
Clears the section list, and also resets the section count and hash
table entries.

`bfd_get_section_by_name'
.........................

   *Synopsis*
     asection *bfd_get_section_by_name(bfd *abfd, const char *name);
   *Description*
Run through ABFD and return the one of the `asection's whose name
matches NAME, otherwise `NULL'.  *Note Sections::, for more information.

   This should only be used in special cases; the normal way to process
all sections of a given name is to use `bfd_map_over_sections' and
`strcmp' on the name (or better yet, base it on the section flags or
something else) for each section.

`bfd_get_unique_section_name'
.............................

   *Synopsis*
     char *bfd_get_unique_section_name(bfd *abfd,
         const char *templat,
         int *count);
   *Description*
Invent a section name that is unique in ABFD by tacking a dot and a
digit suffix onto the original TEMPLAT.  If COUNT is non-NULL, then it
specifies the first number tried as a suffix to generate a unique name.
The value pointed to by COUNT will be incremented in this case.

`bfd_make_section_old_way'
..........................

   *Synopsis*
     asection *bfd_make_section_old_way(bfd *abfd, const char *name);
   *Description*
Create a new empty section called NAME and attach it to the end of the
chain of sections for the BFD ABFD. An attempt to create a section with
a name which is already in use returns its pointer without changing the
section chain.

   It has the funny name since this is the way it used to be before it
was rewritten....

   Possible errors are:
   * `bfd_error_invalid_operation' - If output has already started for
     this BFD.

   * `bfd_error_no_memory' - If memory allocation fails.

`bfd_make_section_anyway'
.........................

   *Synopsis*
     asection *bfd_make_section_anyway(bfd *abfd, const char *name);
   *Description*
Create a new empty section called NAME and attach it to the end of the
chain of sections for ABFD.  Create a new section even if there is
already a section with that name.

   Return `NULL' and set `bfd_error' on error; possible errors are:
   * `bfd_error_invalid_operation' - If output has already started for
     ABFD.

   * `bfd_error_no_memory' - If memory allocation fails.

`bfd_make_section'
..................

   *Synopsis*
     asection *bfd_make_section(bfd *, const char *name);
   *Description*
Like `bfd_make_section_anyway', but return `NULL' (without calling
bfd_set_error ()) without changing the section chain if there is
already a section named NAME.  If there is an error, return `NULL' and
set `bfd_error'.

`bfd_set_section_flags'
.......................

   *Synopsis*
     bfd_boolean bfd_set_section_flags (bfd *abfd, asection *sec, flagword flags);
   *Description*
Set the attributes of the section SEC in the BFD ABFD to the value
FLAGS. Return `TRUE' on success, `FALSE' on error. Possible error
returns are:

   * `bfd_error_invalid_operation' - The section cannot have one or
     more of the attributes requested. For example, a .bss section in
     `a.out' may not have the `SEC_HAS_CONTENTS' field set.

`bfd_map_over_sections'
.......................

   *Synopsis*
     void bfd_map_over_sections(bfd *abfd,
         void (*func) (bfd *abfd,
         asection *sect,
         PTR obj),
         PTR obj);
   *Description*
Call the provided function FUNC for each section attached to the BFD
ABFD, passing OBJ as an argument. The function will be called as if by

            func(abfd, the_section, obj);

   This is the prefered method for iterating over sections; an
alternative would be to use a loop:

               section *p;
               for (p = abfd->sections; p != NULL; p = p->next)
                  func(abfd, p, ...)

`bfd_set_section_size'
......................

   *Synopsis*
     bfd_boolean bfd_set_section_size (bfd *abfd, asection *sec, bfd_size_type val);
   *Description*
Set SEC to the size VAL. If the operation is ok, then `TRUE' is
returned, else `FALSE'.

   Possible error returns:
   * `bfd_error_invalid_operation' - Writing has started to the BFD, so
     setting the size is invalid.

`bfd_set_section_contents'
..........................

   *Synopsis*
     bfd_boolean bfd_set_section_contents (bfd *abfd, asection *section,
         PTR data, file_ptr offset,
         bfd_size_type count);
   *Description*
Sets the contents of the section SECTION in BFD ABFD to the data
starting in memory at DATA. The data is written to the output section
starting at offset OFFSET for COUNT octets.

   Normally `TRUE' is returned, else `FALSE'. Possible error returns
are:
   * `bfd_error_no_contents' - The output section does not have the
     `SEC_HAS_CONTENTS' attribute, so nothing can be written to it.

   * and some more too
   This routine is front end to the back end function
`_bfd_set_section_contents'.

`bfd_get_section_contents'
..........................

   *Synopsis*
     bfd_boolean bfd_get_section_contents (bfd *abfd, asection *section,
         PTR location, file_ptr offset,
         bfd_size_type count);
   *Description*
Read data from SECTION in BFD ABFD into memory starting at LOCATION.
The data is read at an offset of OFFSET from the start of the input
section, and is read for COUNT bytes.

   If the contents of a constructor with the `SEC_CONSTRUCTOR' flag set
are requested or if the section does not have the `SEC_HAS_CONTENTS'
flag set, then the LOCATION is filled with zeroes. If no errors occur,
`TRUE' is returned, else `FALSE'.

`bfd_copy_private_section_data'
...............................

   *Synopsis*
     bfd_boolean bfd_copy_private_section_data (bfd *ibfd, asection *isec,
         bfd *obfd, asection *osec);
   *Description*
Copy private section information from ISEC in the BFD IBFD to the
section OSEC in the BFD OBFD.  Return `TRUE' on success, `FALSE' on
error.  Possible error returns are:

   * `bfd_error_no_memory' - Not enough memory exists to create private
     data for OSEC.

     #define bfd_copy_private_section_data(ibfd, isection, obfd, osection) \
          BFD_SEND (obfd, _bfd_copy_private_section_data, \
                    (ibfd, isection, obfd, osection))

`_bfd_strip_section_from_output'
................................

   *Synopsis*
     void _bfd_strip_section_from_output
        (struct bfd_link_info *info, asection *section);
   *Description*
Remove SECTION from the output.  If the output section becomes empty,
remove it from the output bfd.

   This function won't actually do anything except twiddle flags if
called too late in the linking process, when it's not safe to remove
sections.

`bfd_generic_discard_group'
...........................

   *Synopsis*
     bfd_boolean bfd_generic_discard_group (bfd *abfd, asection *group);
   *Description*
Remove all members of GROUP from the output.


File: bfd.info,  Node: Symbols,  Next: Archives,  Prev: Sections,  Up: BFD front end

Symbols
=======

   BFD tries to maintain as much symbol information as it can when it
moves information from file to file. BFD passes information to
applications though the `asymbol' structure. When the application
requests the symbol table, BFD reads the table in the native form and
translates parts of it into the internal format. To maintain more than
the information passed to applications, some targets keep some
information "behind the scenes" in a structure only the particular back
end knows about. For example, the coff back end keeps the original
symbol table structure as well as the canonical structure when a BFD is
read in. On output, the coff back end can reconstruct the output symbol
table so that no information is lost, even information unique to coff
which BFD doesn't know or understand. If a coff symbol table were read,
but were written through an a.out back end, all the coff specific
information would be lost. The symbol table of a BFD is not necessarily
read in until a canonicalize request is made. Then the BFD back end
fills in a table provided by the application with pointers to the
canonical information.  To output symbols, the application provides BFD
with a table of pointers to pointers to `asymbol's. This allows
applications like the linker to output a symbol as it was read, since
the "behind the scenes" information will be still available.

* Menu:

* Reading Symbols::
* Writing Symbols::
* Mini Symbols::
* typedef asymbol::
* symbol handling functions::


File: bfd.info,  Node: Reading Symbols,  Next: Writing Symbols,  Prev: Symbols,  Up: Symbols

Reading symbols
---------------

   There are two stages to reading a symbol table from a BFD:
allocating storage, and the actual reading process. This is an excerpt
from an application which reads the symbol table:

              long storage_needed;
              asymbol **symbol_table;
              long number_of_symbols;
              long i;
     
              storage_needed = bfd_get_symtab_upper_bound (abfd);
     
              if (storage_needed < 0)
                FAIL
     
              if (storage_needed == 0)
                return;
     
              symbol_table = (asymbol **) xmalloc (storage_needed);
                ...
              number_of_symbols =
                 bfd_canonicalize_symtab (abfd, symbol_table);
     
              if (number_of_symbols < 0)
                FAIL
     
              for (i = 0; i < number_of_symbols; i++)
                process_symbol (symbol_table[i]);

   All storage for the symbols themselves is in an objalloc connected
to the BFD; it is freed when the BFD is closed.


File: bfd.info,  Node: Writing Symbols,  Next: Mini Symbols,  Prev: Reading Symbols,  Up: Symbols

Writing symbols
---------------

   Writing of a symbol table is automatic when a BFD open for writing
is closed. The application attaches a vector of pointers to pointers to
symbols to the BFD being written, and fills in the symbol count. The
close and cleanup code reads through the table provided and performs
all the necessary operations. The BFD output code must always be
provided with an "owned" symbol: one which has come from another BFD,
or one which has been created using `bfd_make_empty_symbol'.  Here is an
example showing the creation of a symbol table with only one element:

            #include "bfd.h"
            int main (void)
            {
              bfd *abfd;
              asymbol *ptrs[2];
              asymbol *new;
     
              abfd = bfd_openw ("foo","a.out-sunos-big");
              bfd_set_format (abfd, bfd_object);
              new = bfd_make_empty_symbol (abfd);
              new->name = "dummy_symbol";
              new->section = bfd_make_section_old_way (abfd, ".text");
              new->flags = BSF_GLOBAL;
              new->value = 0x12345;
     
              ptrs[0] = new;
              ptrs[1] = (asymbol *)0;
     
              bfd_set_symtab (abfd, ptrs, 1);
              bfd_close (abfd);
              return 0;
            }
     
            ./makesym
            nm foo
            00012345 A dummy_symbol

   Many formats cannot represent arbitary symbol information; for
instance, the `a.out' object format does not allow an arbitary number
of sections. A symbol pointing to a section which is not one  of
`.text', `.data' or `.bss' cannot be described.


File: bfd.info,  Node: Mini Symbols,  Next: typedef asymbol,  Prev: Writing Symbols,  Up: Symbols

Mini Symbols
------------

   Mini symbols provide read-only access to the symbol table.  They use
less memory space, but require more time to access.  They can be useful
for tools like nm or objdump, which may have to handle symbol tables of
extremely large executables.

   The `bfd_read_minisymbols' function will read the symbols into
memory in an internal form.  It will return a `void *' pointer to a
block of memory, a symbol count, and the size of each symbol.  The
pointer is allocated using `malloc', and should be freed by the caller
when it is no longer needed.

   The function `bfd_minisymbol_to_symbol' will take a pointer to a
minisymbol, and a pointer to a structure returned by
`bfd_make_empty_symbol', and return a `asymbol' structure.  The return
value may or may not be the same as the value from
`bfd_make_empty_symbol' which was passed in.


File: bfd.info,  Node: typedef asymbol,  Next: symbol handling functions,  Prev: Mini Symbols,  Up: Symbols

typedef asymbol
---------------

   An `asymbol' has the form:


     typedef struct symbol_cache_entry
     {
       /* A pointer to the BFD which owns the symbol. This information
          is necessary so that a back end can work out what additional
          information (invisible to the application writer) is carried
          with the symbol.
     
          This field is *almost* redundant, since you can use section->owner
          instead, except that some symbols point to the global sections
          bfd_{abs,com,und}_section.  This could be fixed by making
          these globals be per-bfd (or per-target-flavor).  FIXME.  */
       struct bfd *the_bfd; /* Use bfd_asymbol_bfd(sym) to access this field.  */
     
       /* The text of the symbol. The name is left alone, and not copied; the
          application may not alter it.  */
       const char *name;
     
       /* The value of the symbol.  This really should be a union of a
          numeric value with a pointer, since some flags indicate that
          a pointer to another symbol is stored here.  */
       symvalue value;
     
       /* Attributes of a symbol.  */
     #define BSF_NO_FLAGS    0x00
     
       /* The symbol has local scope; `static' in `C'. The value
          is the offset into the section of the data.  */
     #define BSF_LOCAL      0x01
     
       /* The symbol has global scope; initialized data in `C'. The
          value is the offset into the section of the data.  */
     #define BSF_GLOBAL     0x02
     
       /* The symbol has global scope and is exported. The value is
          the offset into the section of the data.  */
     #define BSF_EXPORT     BSF_GLOBAL /* No real difference.  */
     
       /* A normal C symbol would be one of:
          `BSF_LOCAL', `BSF_FORT_COMM',  `BSF_UNDEFINED' or
          `BSF_GLOBAL'.  */
     
       /* The symbol is a debugging record. The value has an arbitary
          meaning, unless BSF_DEBUGGING_RELOC is also set.  */
     #define BSF_DEBUGGING  0x08
     
       /* The symbol denotes a function entry point.  Used in ELF,
          perhaps others someday.  */
     #define BSF_FUNCTION    0x10
     
       /* Used by the linker.  */
     #define BSF_KEEP        0x20
     #define BSF_KEEP_G      0x40
     
       /* A weak global symbol, overridable without warnings by
          a regular global symbol of the same name.  */
     #define BSF_WEAK        0x80
     
       /* This symbol was created to point to a section, e.g. ELF's
          STT_SECTION symbols.  */
     #define BSF_SECTION_SYM 0x100
     
       /* The symbol used to be a common symbol, but now it is
          allocated.  */
     #define BSF_OLD_COMMON  0x200
     
       /* The default value for common data.  */
     #define BFD_FORT_COMM_DEFAULT_VALUE 0
     
       /* In some files the type of a symbol sometimes alters its
          location in an output file - ie in coff a `ISFCN' symbol
          which is also `C_EXT' symbol appears where it was
          declared and not at the end of a section.  This bit is set
          by the target BFD part to convey this information.  */
     #define BSF_NOT_AT_END    0x400
     
       /* Signal that the symbol is the label of constructor section.  */
     #define BSF_CONSTRUCTOR   0x800
     
       /* Signal that the symbol is a warning symbol.  The name is a
          warning.  The name of the next symbol is the one to warn about;
          if a reference is made to a symbol with the same name as the next
          symbol, a warning is issued by the linker.  */
     #define BSF_WARNING       0x1000
     
       /* Signal that the symbol is indirect.  This symbol is an indirect
          pointer to the symbol with the same name as the next symbol.  */
     #define BSF_INDIRECT      0x2000
     
       /* BSF_FILE marks symbols that contain a file name.  This is used
          for ELF STT_FILE symbols.  */
     #define BSF_FILE          0x4000
     
       /* Symbol is from dynamic linking information.  */
     #define BSF_DYNAMIC       0x8000
     
       /* The symbol denotes a data object.  Used in ELF, and perhaps
          others someday.  */
     #define BSF_OBJECT        0x10000
     
       /* This symbol is a debugging symbol.  The value is the offset
          into the section of the data.  BSF_DEBUGGING should be set
          as well.  */
     #define BSF_DEBUGGING_RELOC 0x20000
     
       /* This symbol is thread local.  Used in ELF.  */
     #define BSF_THREAD_LOCAL  0x40000
     
       flagword flags;
     
       /* A pointer to the section to which this symbol is
          relative.  This will always be non NULL, there are special
          sections for undefined and absolute symbols.  */
       struct sec *section;
     
       /* Back end special data.  */
       union
         {
           PTR p;
           bfd_vma i;
         }
       udata;
     }
     asymbol;


File: bfd.info,  Node: symbol handling functions,  Prev: typedef asymbol,  Up: Symbols

Symbol handling functions
-------------------------

`bfd_get_symtab_upper_bound'
............................

   *Description*
Return the number of bytes required to store a vector of pointers to
`asymbols' for all the symbols in the BFD ABFD, including a terminal
NULL pointer. If there are no symbols in the BFD, then return 0.  If an
error occurs, return -1.
     #define bfd_get_symtab_upper_bound(abfd) \
          BFD_SEND (abfd, _bfd_get_symtab_upper_bound, (abfd))

`bfd_is_local_label'
....................

   *Synopsis*
     bfd_boolean bfd_is_local_label (bfd *abfd, asymbol *sym);
   *Description*
Return TRUE if the given symbol SYM in the BFD ABFD is a compiler
generated local label, else return FALSE.

`bfd_is_local_label_name'
.........................

   *Synopsis*
     bfd_boolean bfd_is_local_label_name (bfd *abfd, const char *name);
   *Description*
Return TRUE if a symbol with the name NAME in the BFD ABFD is a
compiler generated local label, else return FALSE.  This just checks
whether the name has the form of a local label.
     #define bfd_is_local_label_name(abfd, name) \
          BFD_SEND (abfd, _bfd_is_local_label_name, (abfd, name))

`bfd_canonicalize_symtab'
.........................

   *Description*
Read the symbols from the BFD ABFD, and fills in the vector LOCATION
with pointers to the symbols and a trailing NULL.  Return the actual
number of symbol pointers, not including the NULL.
     #define bfd_canonicalize_symtab(abfd, location) \
          BFD_SEND (abfd, _bfd_canonicalize_symtab,\
                       (abfd, location))

`bfd_set_symtab'
................

   *Synopsis*
     bfd_boolean bfd_set_symtab (bfd *abfd, asymbol **location, unsigned int count);
   *Description*
Arrange that when the output BFD ABFD is closed, the table LOCATION of
COUNT pointers to symbols will be written.

`bfd_print_symbol_vandf'
........................

   *Synopsis*
     void bfd_print_symbol_vandf (bfd *abfd, PTR file, asymbol *symbol);
   *Description*
Print the value and flags of the SYMBOL supplied to the stream FILE.

`bfd_make_empty_symbol'
.......................

   *Description*
Create a new `asymbol' structure for the BFD ABFD and return a pointer
to it.

   This routine is necessary because each back end has private
information surrounding the `asymbol'. Building your own `asymbol' and
pointing to it will not create the private information, and will cause
problems later on.
     #define bfd_make_empty_symbol(abfd) \
          BFD_SEND (abfd, _bfd_make_empty_symbol, (abfd))

`_bfd_generic_make_empty_symbol'
................................

   *Synopsis*
     asymbol * _bfd_generic_make_empty_symbol (bfd *);
   *Description*
Create a new `asymbol' structure for the BFD ABFD and return a pointer
to it.  Used by core file routines, binary back-end and anywhere else
where no private info is needed.

`bfd_make_debug_symbol'
.......................

   *Description*
Create a new `asymbol' structure for the BFD ABFD, to be used as a
debugging symbol.  Further details of its use have yet to be worked out.
     #define bfd_make_debug_symbol(abfd,ptr,size) \
             BFD_SEND (abfd, _bfd_make_debug_symbol, (abfd, ptr, size))

`bfd_decode_symclass'
.....................

   *Description*
Return a character corresponding to the symbol class of SYMBOL, or '?'
for an unknown class.

   *Synopsis*
     int bfd_decode_symclass (asymbol *symbol);

`bfd_is_undefined_symclass'
...........................

   *Description*
Returns non-zero if the class symbol returned by bfd_decode_symclass
represents an undefined symbol.  Returns zero otherwise.

   *Synopsis*
     bfd_boolean bfd_is_undefined_symclass (int symclass);

`bfd_symbol_info'
.................

   *Description*
Fill in the basic info about symbol that nm needs.  Additional info may
be added by the back-ends after calling this function.

   *Synopsis*
     void bfd_symbol_info (asymbol *symbol, symbol_info *ret);

`bfd_copy_private_symbol_data'
..............................

   *Synopsis*
     bfd_boolean bfd_copy_private_symbol_data (bfd *ibfd, asymbol *isym, bfd *obfd, asymbol *osym);
   *Description*
Copy private symbol information from ISYM in the BFD IBFD to the symbol
OSYM in the BFD OBFD.  Return `TRUE' on success, `FALSE' on error.
Possible error returns are:

   * `bfd_error_no_memory' - Not enough memory exists to create private
     data for OSEC.

     #define bfd_copy_private_symbol_data(ibfd, isymbol, obfd, osymbol) \
          BFD_SEND (obfd, _bfd_copy_private_symbol_data, \
                    (ibfd, isymbol, obfd, osymbol))


File: bfd.info,  Node: Archives,  Next: Formats,  Prev: Symbols,  Up: BFD front end

Archives
========

   *Description*
An archive (or library) is just another BFD.  It has a symbol table,
although there's not much a user program will do with it.

   The big difference between an archive BFD and an ordinary BFD is
that the archive doesn't have sections.  Instead it has a chain of BFDs
that are considered its contents.  These BFDs can be manipulated like
any other.  The BFDs contained in an archive opened for reading will
all be opened for reading.  You may put either input or output BFDs
into an archive opened for output; they will be handled correctly when
the archive is closed.

   Use `bfd_openr_next_archived_file' to step through the contents of
an archive opened for input.  You don't have to read the entire archive
if you don't want to!  Read it until you find what you want.

   Archive contents of output BFDs are chained through the `next'
pointer in a BFD.  The first one is findable through the `archive_head'
slot of the archive.  Set it with `bfd_set_archive_head' (q.v.).  A
given BFD may be in only one open output archive at a time.

   As expected, the BFD archive code is more general than the archive
code of any given environment.  BFD archives may contain files of
different formats (e.g., a.out and coff) and even different
architectures.  You may even place archives recursively into archives!

   This can cause unexpected confusion, since some archive formats are
more expressive than others.  For instance, Intel COFF archives can
preserve long filenames; SunOS a.out archives cannot.  If you move a
file from the first to the second format and back again, the filename
may be truncated.  Likewise, different a.out environments have different
conventions as to how they truncate filenames, whether they preserve
directory names in filenames, etc.  When interoperating with native
tools, be sure your files are homogeneous.

   Beware: most of these formats do not react well to the presence of
spaces in filenames.  We do the best we can, but can't always handle
this case due to restrictions in the format of archives.  Many Unix
utilities are braindead in regards to spaces and such in filenames
anyway, so this shouldn't be much of a restriction.

   Archives are supported in BFD in `archive.c'.

`bfd_get_next_mapent'
.....................

   *Synopsis*
     symindex bfd_get_next_mapent(bfd *abfd, symindex previous, carsym **sym);
   *Description*
Step through archive ABFD's symbol table (if it has one).  Successively
update SYM with the next symbol's information, returning that symbol's
(internal) index into the symbol table.

   Supply `BFD_NO_MORE_SYMBOLS' as the PREVIOUS entry to get the first
one; returns `BFD_NO_MORE_SYMBOLS' when you've already got the last one.

   A `carsym' is a canonical archive symbol.  The only user-visible
element is its name, a null-terminated string.

`bfd_set_archive_head'
......................

   *Synopsis*
     bfd_boolean bfd_set_archive_head(bfd *output, bfd *new_head);
   *Description*
Set the head of the chain of BFDs contained in the archive OUTPUT to
NEW_HEAD.

`bfd_openr_next_archived_file'
..............................

   *Synopsis*
     bfd *bfd_openr_next_archived_file(bfd *archive, bfd *previous);
   *Description*
Provided a BFD, ARCHIVE, containing an archive and NULL, open an input
BFD on the first contained element and returns that.  Subsequent calls
should pass the archive and the previous return value to return a
created BFD to the next contained element. NULL is returned when there
are no more.


File: bfd.info,  Node: Formats,  Next: Relocations,  Prev: Archives,  Up: BFD front end

File formats
============

   A format is a BFD concept of high level file contents type. The
formats supported by BFD are:

   * `bfd_object'
   The BFD may contain data, symbols, relocations and debug info.

   * `bfd_archive'
   The BFD contains other BFDs and an optional index.

   * `bfd_core'
   The BFD contains the result of an executable core dump.

`bfd_check_format'
..................

   *Synopsis*
     bfd_boolean bfd_check_format (bfd *abfd, bfd_format format);
   *Description*
Verify if the file attached to the BFD ABFD is compatible with the
format FORMAT (i.e., one of `bfd_object', `bfd_archive' or `bfd_core').

   If the BFD has been set to a specific target before the call, only
the named target and format combination is checked. If the target has
not been set, or has been set to `default', then all the known target
backends is interrogated to determine a match.  If the default target
matches, it is used.  If not, exactly one target must recognize the
file, or an error results.

   The function returns `TRUE' on success, otherwise `FALSE' with one
of the following error codes:

   * `bfd_error_invalid_operation' - if `format' is not one of
     `bfd_object', `bfd_archive' or `bfd_core'.

   * `bfd_error_system_call' - if an error occured during a read - even
     some file mismatches can cause bfd_error_system_calls.

   * `file_not_recognised' - none of the backends recognised the file
     format.

   * `bfd_error_file_ambiguously_recognized' - more than one backend
     recognised the file format.

`bfd_check_format_matches'
..........................

   *Synopsis*
     bfd_boolean bfd_check_format_matches (bfd *abfd, bfd_format format,
         char ***matching);
   *Description*
Like `bfd_check_format', except when it returns FALSE with `bfd_errno'
set to `bfd_error_file_ambiguously_recognized'.  In that case, if
MATCHING is not NULL, it will be filled in with a NULL-terminated list
of the names of the formats that matched, allocated with `malloc'.
Then the user may choose a format and try again.

   When done with the list that MATCHING points to, the caller should
free it.

`bfd_set_format'
................

   *Synopsis*
     bfd_boolean bfd_set_format (bfd *abfd, bfd_format format);
   *Description*
This function sets the file format of the BFD ABFD to the format
FORMAT. If the target set in the BFD does not support the format
requested, the format is invalid, or the BFD is not open for writing,
then an error occurs.

`bfd_format_string'
...................

   *Synopsis*
     const char *bfd_format_string (bfd_format format);
   *Description*
Return a pointer to a const string `invalid', `object', `archive',
`core', or `unknown', depending upon the value of FORMAT.


File: bfd.info,  Node: Relocations,  Next: Core Files,  Prev: Formats,  Up: BFD front end

Relocations
===========

   BFD maintains relocations in much the same way it maintains symbols:
they are left alone until required, then read in en-masse and
translated into an internal form.  A common routine
`bfd_perform_relocation' acts upon the canonical form to do the fixup.

   Relocations are maintained on a per section basis, while symbols are
maintained on a per BFD basis.

   All that a back end has to do to fit the BFD interface is to create
a `struct reloc_cache_entry' for each relocation in a particular
section, and fill in the right bits of the structures.

* Menu:

* typedef arelent::
* howto manager::

